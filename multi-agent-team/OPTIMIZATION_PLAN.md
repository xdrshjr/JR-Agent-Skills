# Multi-Agent Team Skill 优化计划
## 增加验证员/测试员角色

---

## 一、核心变更概述

### 现有流程
```
项目经理规划分发 → 员工执行 → 项目经理验收 → 交付用户
```

### 新流程（增加验证层）
```
项目经理规划分发 → 员工执行 → 验证员规划验证方案 → 验证员逐项验证 
    ↓ (不通过，打回修改)
    ↓ (通过)
项目经理最终验收 → 交付用户
```

---

## 二、新角色定义：验证员/测试员 (QA Agent)

### 2.1 角色职责

| 阶段 | 职责 |
|------|------|
| **验证规划** | 根据PM的原任务规划，制定详细的验证方案和标准 |
| **逐项验证** | 对每个员工交付的成果进行独立验证 |
| **结果判定** | 给出通过/不通过的明确结论 |
| **反馈指导** | 不通过时提供具体的修改建议 |
| **汇总报告** | 生成完整的验证报告提交给PM |

### 2.2 验证员工作流程

```
收到验证任务
    ↓
【阶段1：理解任务】阅读PM的原规划，理解每个子任务的目标
    ↓
【阶段2：制定验证方案】规划每个交付物的验证方法、标准和步骤
    ↓ (汇报PM审批)
    ↓
【阶段3：执行验证】逐项检查员工交付物
    ↓
【阶段4：反馈迭代】对不合格项打回修改，直到通过
    ↓
【阶段5：生成报告】汇总所有验证结果，提交PM
```

---

## 三、完整工作流程（详细版）

### 阶段1：项目启动（PM主导）

**步骤1.1 - 任务分析与团队组建**
- PM分析用户请求
- PM决定需要几个执行员工 + 1个验证员
- 技能分配（验证员也需要了解相关技能）

**步骤1.2 - 任务规划与分发**
- PM制定整体项目规划
- PM向各执行员工分发任务
- PM向验证员发送：**原任务规划 + 各员工任务描述 + 预期交付物清单**

### 阶段2：执行阶段（执行员工）

**步骤2.1 - 员工执行**
- 各执行员工按原流程工作（规划→PM审批→执行）
- 完成后将交付物提交给**验证员**（而非PM）
- 员工状态更新为："待验证"

### 阶段3：验证规划（验证员）

**步骤3.1 - 验证员接收任务**
- 验证员收到：原规划 + 所有员工任务 + 预期交付物

**步骤3.2 - 制定验证方案**
验证员制定方案，包含：
- 每个交付物的验证方法（如：功能测试、代码审查、内容检查等）
- 验收标准（明确什么算通过）
- 验证步骤（具体操作流程）
- 验证工具（需要使用的skill或工具）

**步骤3.3 - PM审批验证方案**
- 验证员向PM汇报验证方案
- PM审批后，验证员才能开始验证

### 阶段4：执行验证（验证员）

**步骤4.1 - 逐项验证**
- 验证员按方案逐一验证每个员工交付物
- 记录验证结果（通过/不通过 + 详细说明）

**步骤4.2 - 结果处理**

| 结果 | 操作 |
|------|------|
| **通过** | 标记完成，进入汇总 |
| **不通过** | 打回给对应员工，附上修改建议 |

**步骤4.3 - 迭代修复（如需要）**
- 被打回的员工修改后重新提交给验证员
- 验证员再次验证
- 循环直到通过或达到最大重试次数

### 阶段5：验证报告（验证员）

**步骤5.1 - 生成验证报告**
报告包含：
- 验证概述（总体通过率）
- 逐项验证结果
- 发现的问题及修复情况
- 最终结论：是否通过验证

**步骤5.2 - 提交PM**
- 验证员将报告 + 所有交付物 提交给PM

### 阶段6：最终验收（PM主导）

**步骤6.1 - PM最终审查**
- PM审查验证报告
- PM抽查关键交付物
- 确认整体质量

**步骤6.2 - 交付用户**
- PM整合所有成果
- 向用户交付最终成果

---

## 四、通信协议更新

### 4.1 新增通信流程

```
PM → 执行员工: 任务分配
PM → 验证员: 验证任务分配（含原规划）
执行员工 → 验证员: 交付物提交
验证员 → 执行员工: 验证反馈（通过/打回）
验证员 → PM: 验证方案（待审批）
验证员 → PM: 验证报告（完成后）
```

### 4.2 验证员任务分配模板

```
你是一个验证员/测试员，负责验证团队成员的工作成果。

═══════════════════════════════════════════════════════════
📋 验证任务信息
═══════════════════════════════════════════════════════════

【原始项目规划】
{pm_original_plan}

【执行员工任务清单】
员工1 ({role1}): {task1} → 预期交付: {deliverable1}
员工2 ({role2}): {task2} → 预期交付: {deliverable2}
员工3 ({role3}): {task3} → 预期交付: {deliverable3}

【验证要求】
1. 先制定详细的验证方案，汇报PM审批
2. 按方案逐一验证每个交付物
3. 不通过的给出具体修改建议，打回员工
4. 通过的标记并汇总
5. 最终生成验证报告提交PM

【验证标准】
- 功能性：是否实现了任务要求
- 完整性：是否包含所有必需内容
- 质量：是否符合专业标准
- 一致性：是否与整体项目协调

═══════════════════════════════════════════════════════════
🛠️ 可用工具与技能
═══════════════════════════════════════════════════════════
{available_skills}

⚠️ 验证流程：
1. 阶段汇报：理解任务完成 → PM确认
2. 阶段汇报：验证方案制定完成 → PM审批
3. 进度汇报：验证进度（每完成一个员工）
4. 最终结果：验证报告 → PM
```

### 4.3 验证报告模板

```
📊 验证报告 —— {project_name}

═══════════════════════════════════════════════════════════
【验证概述】
• 验证日期: {date}
• 验证员: {qa_agent_label}
• 验证对象数: {n} 个员工交付物
• 总体结果: ✅ 全部通过 / ⚠️ 部分通过 / ❌ 未通过

═══════════════════════════════════════════════════════════
【逐项验证结果】

员工1 - {role1}:
  交付物: {deliverable1}
  状态: ✅ 通过 / ❌ 不通过
  验证详情:
    • 功能性: 符合/不符合 - 说明
    • 完整性: 符合/不符合 - 说明
    • 质量: 符合/不符合 - 说明
  问题记录: {issues}
  修复情况: {fix_status}

员工2 - {role2}:
  ...

═══════════════════════════════════════════════════════════
【发现的问题汇总】
• 问题1: ... (已修复/待修复)
• 问题2: ...

═══════════════════════════════════════════════════════════
【结论与建议】
• 是否通过验证: 是/否
• 建议PM关注: ...
• 建议后续优化: ...
```

---

## 五、状态管理更新

### 5.1 新增状态值

```json
{
  "agents": {
    "executor-1": {
      "status": "pending_verification",
      "deliverable": "/path/to/file",
      "submittedTo": "qa-agent"
    },
    "qa-agent": {
      "status": "planning_verification",
      "planApproved": false,
      "verificationProgress": "2/3",
      "results": {
        "executor-1": {"status": "passed", "issues": []},
        "executor-2": {"status": "failed", "retryCount": 1}
      }
    }
  }
}
```

### 5.2 状态流转图（执行员工）

```
RUNNING → PENDING_VERIFICATION → UNDER_VERIFICATION → PASSED/FAILED
                                              ↓
                                         (FAILED)
                                              ↓
                                    RETURNED_FOR_FIX → RUNNING
```

---

## 六、异常处理

### 6.1 验证员暂停触发条件

与执行员工相同：
- 工具不可用
- 无法确定验证标准
- 交付物格式不兼容
- 验证资源缺失

### 6.2 多次验证不通过处理

设置最大重试次数（如3次）：
- 超过3次仍不通过 → 验证员暂停 → PM介入 → 与用户沟通

---

## 七、实施步骤建议

### 阶段1：文档更新（优先）
1. 更新 SKILL.md，添加验证员角色定义
2. 更新工作流程图
3. 添加验证员任务模板
4. 更新通信协议

### 阶段2：PM逻辑更新
1. 修改团队组建逻辑（n执行+1验证）
2. 修改任务分发逻辑
3. 修改验收流程（先验证员后PM）

### 阶段3：状态管理更新
1. 添加新状态值
2. 更新状态流转逻辑
3. 更新 agent-status.json 结构

### 阶段4：测试验证
1. 使用简单任务测试新流程
2. 验证各阶段通信正常
3. 测试打回修改流程

---

## 八、待确认问题

### 8.1 需要您决策的事项

1. **验证员数量**
   - 方案A：每个项目固定1个验证员
   - 方案B：根据项目复杂度，可配置1-2个验证员

2. **验证方案审批**
   - 方案A：验证方案必须经PM审批后才能执行（更严格）
   - 方案B：验证员可自主制定方案并执行（更高效）

3. **最大重试次数**
   - 员工交付物不通过时，最多允许几次修改？建议：3次

4. **验证员启动时机**
   - 方案A：员工全部完成后再启动验证员（串行）
   - 方案B：PM规划阶段就启动验证员，并行准备验证方案（更快）

5. **验证员角色定位**
   - 方案A：独立专职验证员（只做验证）
   - 方案B：兼职验证员（可以是某个执行员工兼职验证其他人的工作）

### 8.2 我的建议

- 验证员数量：1个（保持团队精简）
- 验证方案审批：需要PM审批（保证质量）
- 最大重试次数：3次
- 启动时机：PM规划阶段就启动（效率更高）
- 角色定位：独立专职验证员（避免利益冲突）

---

## 九、预期收益

1. **质量提升**：双层质检机制，降低交付缺陷
2. **责任分离**：执行与验证分离，更客观
3. **专业分工**：验证员可专注于质量把控
4. **早期发现问题**：验证阶段就能发现并修复问题

---

*请确认以上方案，如有调整意见请告知，确认后我将开始更新 skill 文档。*
