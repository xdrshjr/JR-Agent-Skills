/**
 * State Synchronization Layer
 * Automatically syncs state.json to derived views
 */

import * as path from 'path';
import { writeFile } from 'fs/promises';
import { ProjectState, TeamMember, AgentStatus } from './state-manager';

// ============================================================================
// Sync to Markdown Project File
// ============================================================================

/**
 * Sync state.json to {project-id}.md (human-readable project log)
 */
export async function syncToMarkdown(
  projectId: string,
  state: ProjectState,
  projectDir: string
): Promise<void> {
  const filepath = path.join(projectDir, `${projectId}.md`);
  const content = generateMarkdownContent(state);
  await writeFile(filepath, content, 'utf-8');
}

function generateMarkdownContent(state: ProjectState): string {
  // Leadership section
  let leadershipSection = '';
  if (state.leadership && state.leadership.leaders && state.leadership.leaders.length > 0) {
    const domainLabels: Record<string, string> = { planning: 'Planning Authority (è§„åˆ’æƒ)', execution: 'Execution Authority (æ‰§è¡Œæƒ)', quality: 'Quality Authority (å®¡åˆ¤æƒ)' };
    leadershipSection = `
## Leadership Council (ä¸‰æƒåˆ†ç«‹)

| Domain | Leader | Expertise |
|--------|--------|-----------|
${state.leadership.leaders.map((l: any) => `| ${domainLabels[l.domain] || l.domain} | ${l.roleName} | ${l.expertise} |`).join('\n')}

### Council Decisions

${state.leadership.decisions && state.leadership.decisions.length > 0
  ? `| Timestamp | Type | Domain | Decision | Outcome |
|-----------|------|--------|----------|---------|
${state.leadership.decisions.map((d: any) => `| ${new Date(d.timestamp).toISOString()} | ${d.type} | ${d.primaryDomain} | ${d.decision} | ${d.outcome} |`).join('\n')}`
  : 'No council decisions recorded yet.'}

### Cross-Checks

${state.leadership.crossChecks && state.leadership.crossChecks.length > 0
  ? `| ID | Type | Primary | Status | Created |
|-----|------|---------|--------|---------|
${state.leadership.crossChecks.map((c: any) => `| ${c.id} | ${c.decisionType} | ${c.primaryDomain} | ${c.status} | ${new Date(c.createdAt).toISOString()} |`).join('\n')}`
  : 'No cross-checks recorded yet.'}

`;
  }

  return `# Project: ${state.id}

## Metadata

| Field | Value |
|-------|-------|
| **Project ID** | ${state.id} |
| **Status** | ${state.status} |
| **Mode** | ${state.mode} |
| **Created** | ${state.createdAt} |
| **Updated** | ${state.updatedAt} |

## User Request

${state.userRequest}
${leadershipSection}
## Team

| Role | Layer | Agent ID | Status | Rework Count | Deliverable |
|------|-------|----------|--------|--------------|-------------|
${state.team.map(m => `| ${m.role} | ${(m as any).layer || 'executor'} | ${m.agentId} | ${m.status} | ${m.reworkCount} | ${m.deliverable || '-'} |`).join('\n')}

## Milestones

| Milestone | Status | User Confirmed | Timestamp |
|-----------|--------|----------------|-----------|
${state.milestones.map(m => `| ${m.name} | ${m.status} | ${m.userConfirmed !== undefined ? (m.userConfirmed ? 'âœ…' : 'â³') : '-'} | ${m.timestamp || '-'} |`).join('\n')}

## Execution Log

| Timestamp | Phase | Event | Details |
|-----------|-------|-------|---------|
${state.logs.map(l => `| ${l.timestamp} | ${l.phase} | ${l.event} | ${l.details || '-'} |`).join('\n')}

## Disputes

${state.disputes.length === 0 ? 'No disputes recorded.' : state.disputes.map(d => `
### ${d.id}
- **Agents:** ${d.agents.join(', ')}
- **Topic:** ${d.topic}
- **Round:** ${d.round}
- **Resolution:** ${d.resolution || 'Pending'}
- **Timestamp:** ${d.timestamp}
`).join('\n')}

---

*This file is automatically generated and synchronized from state.json.*
`;
}

// ============================================================================
// Sync to Agent Status JSON
// ============================================================================

/**
 * Sync state.json to agent-status.json (real-time agent execution state)
 */
export async function syncToAgentStatus(
  projectId: string,
  state: ProjectState,
  projectDir: string
): Promise<void> {
  const filepath = path.join(projectDir, 'agent-status.json');

  // Extract agent status from state
  const agentStatusData: Record<string, any> = {
    projectId: state.id,
    lastUpdate: state.updatedAt,
    agents: state.agentStatus || {},
    teamMembers: state.team.map(member => ({
      role: member.role,
      agentId: member.agentId,
      status: member.status,
      layer: (member as any).layer || 'executor',
      domain: (member as any).domain,
      deliverable: member.deliverable,
      reworkCount: member.reworkCount,
    })),
  };

  // Include leadership info if available
  if (state.leadership && state.leadership.leaders) {
    agentStatusData.leadership = {
      leaders: state.leadership.leaders.map((l: any) => ({
        domain: l.domain,
        roleName: l.roleName,
        status: 'active',
      })),
    };
  }

  await writeFile(filepath, JSON.stringify(agentStatusData, null, 2), 'utf-8');
}

// ============================================================================
// Sync to Whiteboard Markdown
// ============================================================================

/**
 * Sync state.json to WHITEBOARD.md (team communication board)
 */
export async function syncToWhiteboard(
  projectId: string,
  state: ProjectState,
  projectDir: string
): Promise<void> {
  const filepath = path.join(projectDir, 'WHITEBOARD.md');
  const content = generateWhiteboardContent(state);
  await writeFile(filepath, content, 'utf-8');
}

function generateWhiteboardContent(state: ProjectState): string {
  const whiteboard = state.whiteboard || {
    teamMembers: [],
    currentPhase: 'init',
    blockers: [],
    decisions: [],
    lastUpdate: state.updatedAt,
  };

  // Leadership Council section
  let leadershipSection = '';
  if (state.leadership && state.leadership.leaders && state.leadership.leaders.length > 0) {
    const domainLabels: Record<string, string> = { planning: 'è§„åˆ’æƒ', execution: 'æ‰§è¡Œæƒ', quality: 'å®¡åˆ¤æƒ' };

    // Count pending cross-checks per domain
    const pendingChecks = (state.leadership.crossChecks || [])
      .filter((c: any) => c.status === 'pending' || c.status === 'objected');

    leadershipSection = `
## ðŸ›ï¸ Leadership Council

| æƒåŠ›åŸŸ | Leader | çŠ¶æ€ | å¾…å¤„ç† |
|--------|--------|------|--------|
${state.leadership.leaders.map((l: any) => {
  const pending = pendingChecks.filter((c: any) =>
    c.requiredSignoffs && c.requiredSignoffs.includes(l.domain) &&
    !c.signoffs?.some((s: any) => s.domain === l.domain && s.approved)
  ).length;
  return `| ${domainLabels[l.domain] || l.domain} | ${l.roleName} | ðŸŸ¢ Active | ${pending > 0 ? `${pending} pending` : '-'} |`;
}).join('\n')}

---
`;
  }

  return `# Team Whiteboard - ${state.id}

**Last Update:** ${whiteboard.lastUpdate}
**Current Phase:** ${whiteboard.currentPhase}

---
${leadershipSection}
## ðŸ‘¥ Team Members

${whiteboard.teamMembers.length === 0 ? 'No team members yet.' : whiteboard.teamMembers.map(member =>
  `- **${member.role}** (${member.agentId}): ${member.status}`
).join('\n')}

---

## ðŸš§ Current Blockers

${whiteboard.blockers.length === 0 ? 'No blockers.' : whiteboard.blockers.map(blocker =>
  `- **${blocker.agentId}**: ${blocker.issue} _(${blocker.timestamp})_`
).join('\n')}

---

## ðŸ“‹ Key Decisions

${whiteboard.decisions.length === 0 ? 'No decisions recorded yet.' : whiteboard.decisions.map(decision =>
  `- **${decision.topic}**: ${decision.decision} _(${decision.timestamp})_`
).join('\n')}

---

## ðŸ“Š Agent Status Details

${state.agentStatus && Object.keys(state.agentStatus).length > 0 ?
  Object.values(state.agentStatus).map(agent => `
### ${agent.role} (${agent.agentId})
- **State:** ${agent.state}
- **Phase:** ${agent.phase}
- **Progress:** ${agent.progress}%
- **Last Update:** ${agent.lastUpdate}
${agent.restartCount ? `- **Restart Count:** ${agent.restartCount}` : ''}
${agent.timeoutHistory && agent.timeoutHistory.length > 0 ? `- **Timeout History:** ${agent.timeoutHistory.length} timeout(s)` : ''}
`).join('\n') : 'No agent status details available.'}

---

*This whiteboard is automatically synchronized from state.json.*
`;
}

// ============================================================================
// Sync All Derived Views
// ============================================================================

/**
 * Sync state.json to all derived views
 */
export async function syncAll(
  projectId: string,
  state: ProjectState,
  projectDir: string
): Promise<void> {
  await Promise.all([
    syncToMarkdown(projectId, state, projectDir),
    syncToAgentStatus(projectId, state, projectDir),
    syncToWhiteboard(projectId, state, projectDir),
  ]);
}
